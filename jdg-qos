#!/bin/sh -eu

# NOTES:
# * tc earlier than version 110629 miscomputes ewma for choke
#	- workaround is to pass min as 'min/avpkt'
# * tc filter for ipv6 priority does not work
#	- workaround is to use u32 instead

# uncomment to enable debugging
set -x

chkerr () {
	[ $? -ne 0 ] && echo error, please enable debugging and report
}
trap chkerr 0

########## User Configurable Section ##########

# bottleneck assumed to be the uplink
V4INT=$(ip -4 route show default | sed 's/^.* dev \([^ ]\+\).*$/\1/')
V6INT=$(ip -6 route show default | sed 's/^.* dev \([^ ]\+\).*$/\1/')

# bottleneck rate in kbps
DRATE=$(awk '/Connection Rate/ { print $8 }' /proc/avalanche/avsar_modem_stats)
URATE=$(awk '/Connection Rate/ { print $4 }' /proc/avalanche/avsar_modem_stats)

# base latency to next hop on an idle link
LAT=20

# EF rate in kbps
DEF=64
UEF=64

# ATM encapsulation - set to non-zero to enable
# http://www.linuxhowtos.org/manpages/8/tc-stab.htm
OVERHEAD=32

###############################################

if [ -z "$V4INT" -a -z "$V6INT" ]; then
	echo must have at least an v4 or v6 interface defined
	exit 1
fi
# preference for v4 as v6 might be a tunnel
[ "$V4INT" ] && IFACE=$V4INT || IFACE=$V6INT

if [ "x$1" == "xstatus" ]; then
	tc -s qdisc  show dev $IFACE
	tc -s class  show dev $IFACE
	tc -s qdisc  show dev ifb0
	tc -s class  show dev ifb0
	exit 0
fi

MTU=$(ip link show dev $IFACE | head -n1 | sed 's/^.* mtu \([^ ]\+\) .\+$/\1/')

TCVER=$(tc -Version | sed 's/^.*-ss\(.*\)$/\1/')
#[ $(tc qdisc add choke 2> /dev/null; echo $?) -eq 1 ] && SCHED=choke || SCHED=red
# FIXME we only support RED for now
SCHED=red

_ipt () {
	local PARAMS

	if [ "$V4INT" ]; then
		iptables  -t mangle $@
	fi
	if [ "$V6INT" ]; then
		PARAMS=$(echo $@ | sed 's/icmp/icmpv6/g')

		ip6tables -t mangle $PARAMS
	fi
}

ipt () {
	_ipt -A jdg-qos $@
}

ipt_stop () {
	sysctl -w net.netfilter.nf_conntrack_acct=0 > /dev/null

	_ipt -D PREROUTING -j jdg-qos 2> /dev/null || true
	_ipt -F jdg-qos               2> /dev/null || true
	_ipt -X jdg-qos               2> /dev/null || true
}

ipt_init () {
	_ipt -N jdg-qos
}

ipt_start () {
	sysctl -w net.netfilter.nf_conntrack_acct=1 > /dev/null

	_ipt -A PREROUTING -j jdg-qos
}

ipt_rules () {
	# FIXME we need to handle packets with DSCP already set to something
	#	that does not map to AF/BE/EF otherwise that traffic is dropped

	ipt -p tcp -m multiport --ports 1234 \
		-j DSCP --set-dscp-class EF

	# DNS
	ipt -p udp -m multiport --ports domain -j DSCP --set-dscp-class AF31
	ipt -p tcp -m multiport --ports domain -j DSCP --set-dscp-class AF31

	# HTTP(S)
	ipt -p tcp -m multiport --ports www,https \
		-j DSCP --set-dscp-class AF12
	ipt -p tcp -m multiport --ports www,https \
		-m connbytes --connbytes 0:$((512*1024)) \
			--connbytes-dir both --connbytes-mode bytes \
		-j DSCP --set-dscp-class AF22

	# SSH an Telnet
	ipt -p tcp -m multiport --ports ssh,telnet \
		-j DSCP --set-dscp-class AF32
	ipt -p tcp -m multiport --ports ssh \
		-m tos --tos Maximize-Throughput \
		-j DSCP --set-dscp-class AF22

	# ICMP
	ipt -p icmp                          -j DSCP --set-dscp-class AF41
	ipt -p icmp --icmp-type echo-request -j DSCP --set-dscp-class AF42
	ipt -p icmp --icmp-type echo-reply   -j DSCP --set-dscp-class AF42

	# TCP
	ipt -p tcp ! --tcp-flags SYN,FIN,RST     NONE \
		-j DSCP --set-dscp-class AF41
	ipt -p tcp   --tcp-flags SYN,ACK,FIN,RST ACK \
		-m length --length 32:40 \
		-j DSCP --set-dscp-class AF42
}

qos_stop () {
	tc qdisc del dev $IFACE	root	2> /dev/null || true
	tc qdisc del dev $IFACE	ingress	2> /dev/null || true

	tc qdisc del dev ifb0	root	2> /dev/null || true
	ip link set ifb0 down		2> /dev/null || true

	modprobe -r ifb			2> /dev/null || true
}

qos_rules () {
	local STAB

	[ $OVERHEAD -ne 0 ] && STAB="stab linklayer atm overhead $OVERHEAD mtu $MTU"

	modprobe ifb numifbs=1
	ip link set ifb0 up
	tc qdisc add dev $IFACE ingress handle ffff:
	tc filter add dev $IFACE parent ffff: protocol all prio 1 \
		basic action mirred egress redirect dev ifb0

	for INT in $IFACE ifb0
	do
		[ $INT = "ifb0" ] && BW=$DRATE || BW=$URATE

		tc qdisc add dev $INT $STAB root       handle  1: prio \
			bands 3 priomap 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
		tc qdisc add dev $INT       parent 1:1 handle 10: tbf \
			rate ${UEF}kbit burst $((2*$MTU)) latency $(($LAT+50))ms
		tc qdisc add dev $INT       parent 1:2 handle 20: drr

		MAX=$((($BW*1000)/(8*2)))
		MIN=$(($MAX/3))
		LIMIT=$((8*$MAX))
		BURST=$(((2*$MIN+$MAX)/(3*1000)))
		[ $SCHED = "choke" -a $TCVER -le 110629 ] \
			&& MINVAR=$(($MIN/1000)) || MINVAR=$MIN
		tc qdisc add dev $INT       parent 1:3 handle  30: $SCHED \
			limit $LIMIT min $MINVAR max $MAX avpkt 1000 burst $BURST \
			bandwidth $BW probability 0.04 ecn

		tc filter add dev $INT protocol ip   prio 1 \
			u32 match ip  tos      0x2e 0xfc classid 1:1
		tc filter add dev $INT protocol ipv6 prio 2 \
			u32 match u32 0x02e00000 0x0fc00000 at 0 classid 1:1

		tc filter add dev $INT protocol ip   prio 1 \
			u32 match ip tos       0x00 0xfc classid 1:3
		tc filter add dev $INT protocol ipv6 prio 2 \
			u32 match u32 0x00000000 0x0fc00000 at 0 classid 1:3

		for QUEUE in	$(seq 10 2 14) $(seq 18 2 22) \
				$(seq 26 2 30) $(seq 34 2 38); do
			tc class  add dev $INT parent 20: classid 20:$QUEUE drr \
				quantum $MTU

			PROB=0.0$((($QUEUE % 8)/3 + ($QUEUE % 8)/3))
			[ $PROB = "0.00" ] && PROB=0.01
			AVPKT=$((500 * ($QUEUE % 8)/2))
			BURST=$(((2*$MIN+$MAX)/(3*AVPKT)))
			[ $SCHED = "choke" -a $TCVER -le 110629 ] \
				&& MINVAR=$(($MIN/$AVPKT)) || MINVAR=$MIN
			tc qdisc  add dev $INT parent 20:$QUEUE $SCHED \
				limit $LIMIT min $MINVAR max $MAX \
				avpkt $AVPKT burst $BURST bandwidth $BW \
				probability $PROB ecn

			tc filter add dev $INT parent 20: protocol ip   prio 1 \
				u32 match ip tos $(printf 0x%x $(($QUEUE*4))) 0xfc \
				classid 20:$QUEUE
			tc filter add dev $INT parent 20: protocol ipv6 prio 2 \
				u32 match u32 \
					$(printf 0x0%x00000 $(($QUEUE*4))) \
					0x0fc00000 at 0 \
				classid 20:$QUEUE
		done
	done
}

qos_stop
ipt_stop
[ "x$1" = "xstop" ] && exit 0
ipt_init
ipt_rules
qos_rules
ipt_start

exit 0
