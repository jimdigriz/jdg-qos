#!/bin/sh -e

# uncomment to enable debugging
set -x

chkerr () {
	[ $? -ne 0 ] && echo error, please enable debugging and report
}
trap chkerr 0

########## User Configurable Section ##########

# bottleneck assumed to be the uplink
V4INT=$(ip -4 route show default | sed 's/^.* dev \([^ ]\+\) .\+$/\1/')
V6INT=$(ip -6 route show default | sed 's/^.* dev \([^ ]\+\) .\+$/\1/')

# bottleneck rate in kbps
DRATE=$(awk '/Connection Rate/ { print $8 }' /proc/avalanche/avsar_modem_stats)
URATE=$(awk '/Connection Rate/ { print $4 }' /proc/avalanche/avsar_modem_stats)

# EF rate in kbps
DEF=64
UEF=64

# ATM encapsulation - set to non-zero to enable
# http://www.linuxhowtos.org/manpages/8/tc-stab.htm
OVERHEAD=32

###############################################

# AF share latency avpkt prob
TABLE="\
AF11:10:50:500:1.00 \
AF12:10:50:500:0.02 \
AF13:10:50:500:0.04 \
AF21:10:50:500:1.00 \
AF22:10:50:500:0.02 \
AF23:10:50:500:0.04 \
AF31:10:50:500:1.00 \
AF32:10:50:500:0.02 \
AF33:10:50:500:0.04 \
AF41:10:50:500:1.00 \
AF42:10:50:500:0.02 \
AF43:10:50:500:0.04"

###############################################

if [ -z "$V4INT" -a -z "$V6INT" ]; then
	echo must have at least an v4 or v6 interface defined
	exit 1
fi
# preference for v4 as v6 might be a tunnel
[ "$V4INT" ] && IFACE=$V4INT || IFACE=$V6INT

if [ "x$1" == "xstatus" ]; then
	tc -s qdisc  show dev $IFACE
	tc -s class  show dev $IFACE
	tc -s qdisc  show dev ifb0
	tc -s class  show dev ifb0
	tc -s filter show dev $IFACE
	tc -s filter show dev $IFACE parent ffff:
	tc -s filter show dev ifb0
	exit 0
fi

MTU=$(ip link show dev $IFACE | head -n1 | sed 's/^.* mtu \([^ ]\+\) .\+$/\1/')

_ipt () {
	local PARAMS

	if [ "$V4INT" ]; then
		iptables  -t mangle $@
	fi
	if [ "$V6INT" ]; then
		PARAMS=$(echo $@ | sed 's/icmp/icmpv6/g')

		ip6tables -t mangle $PARAMS
	fi
}

ipt () {
	_ipt -A jdg-qos $@
}

ipt_stop () {
	sysctl -w net.netfilter.nf_conntrack_acct=0 > /dev/null

	_ipt -D PREROUTING -j jdg-qos 2> /dev/null || true
	_ipt -F jdg-qos               2> /dev/null || true
	_ipt -X jdg-qos               2> /dev/null || true
}

ipt_init () {
	_ipt -N jdg-qos
}

ipt_start () {
	sysctl -w net.netfilter.nf_conntrack_acct=1 > /dev/null

	_ipt -A PREROUTING -j jdg-qos
}

ipt_rules () {
ipt -p icmp --icmp-type echo-request -j DSCP --set-dscp-class AF42
ipt -p icmp --icmp-type echo-reply   -j DSCP --set-dscp-class AF42
ipt -p icmp                          -j DSCP --set-dscp-class AF43
ipt                                  -j DSCP --set-dscp-class AF13
return
	# HTTP(S)
	ipt -p tcp -m multiport --ports 80,443 \
		-m connbytes --connbytes 0:$((512*1024)) \
			--connbytes-dir both --connbytes-mode bytes \
		-j DSCP --set-dscp-class AF22
	ipt -p tcp -m multiport --ports 80,443 \
		-j DSCP --set-dscp-class AF12

	# SSH (plus hook for Telnet which fortunately ToS marks it's packets)
	ipt -p tcp -m multiport --ports 22,23 \
		-m tos --tos Minimize-Delay \
		-j DSCP --set-dscp-class AF32
	ipt -p tcp -m multiport --ports 22 \
		-m tos --tos Normal-Service \
		-j DSCP --set-dscp-class AF22
	ipt -p tcp -m multiport --ports 22 \
		-m tos --tos Maximize-Throughput \
		-j DSCP --set-dscp-class AF12

	# TCP
	ipt -p tcp ! --tcp-flags SYN,FIN,RST     NONE \
		-j DSCP --set-dscp-class AF41
	ipt -p tcp   --tcp-flags SYN,ACK,FIN,RST ACK \
		-m length --length 32:40 \
		-j DSCP --set-dscp-class AF42

	# ICMP
	ipt -p icmp --icmp-type echo-request -j DSCP --set-dscp-class AF42
	ipt -p icmp --icmp-type echo-reply   -j DSCP --set-dscp-class AF42
	ipt -p icmp                          -j DSCP --set-dscp-class AF43
}

qos_stop () {
	tc qdisc del dev $IFACE	root	2> /dev/null || true
	tc qdisc del dev $IFACE	ingress	2> /dev/null || true

	tc qdisc del dev ifb0	root	2> /dev/null || true
	ip link set ifb0 down		2> /dev/null || true
}

qos_rules () {
	local STAB

	[ $OVERHEAD -ne 0 ] && STAB="stab linklayer atm overhead $OVERHEAD mtu $MTU"

	# egress
	tc qdisc add dev $IFACE       root        handle   1: dsmark indices 16 set_tc_index
	tc qdisc add dev $IFACE $STAB parent  1:0 handle  10: prio   bands 2 priomap 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
	tc qdisc add dev $IFACE       parent 10:1 handle 100: tbf    rate ${UEF}kbit burst $((2*$MTU)) latency 50ms
	tc qdisc add dev $IFACE       parent 10:2 handle 200: gred   setup DPs 12 default 11

	modprobe ifb
	ip link set ifb0 up

	# ingress
	tc qdisc add dev $IFACE       ingress     handle ffff:
	tc qdisc add dev ifb0         root        handle    1: dsmark indices 16 set_tc_index
	tc qdisc add dev ifb0   $STAB parent  1:0 handle   10: prio   bands 2 priomap 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
	tc qdisc add dev ifb0         parent 10:1 handle  100: tbf    rate ${DEF}kbit burst $((2*$MTU)) latency 50ms
	tc qdisc add dev ifb0         parent 10:2 handle  200: gred   setup DPs 12 default 11

	for ELEMENT in $TABLE; do
		I=$(echo $ELEMENT | awk 'BEGIN { FS=":" } { \
			C = substr($1, 3, 1); \
			D = substr($1, 4, 1); \
			print 12-((C-1)*3)-(3-D) }')
		S=$(echo $ELEMENT | cut -d: -f 2)
		L=$(echo $ELEMENT | cut -d: -f 3)
		A=$(echo $ELEMENT | cut -d: -f 4)
		P=$(echo $ELEMENT | cut -d: -f 5)

		MAX=$((($S*$L*$URATE)/(8*10)))
		MIN=$(($MAX/2))
		BURST=$(((2*$MIN+$MAX)/(3*$A)))
		LIMIT=$((4*$MAX))

		tc qdisc change dev $IFACE parent 10:2 gred DP $(($I-1)) prio $(($I+7)) probability $P \
				min $MIN max $MAX avpkt $A burst $BURST limit $LIMIT \
				bandwidth ${URATE}kbit

		MAX=$((($S*$L*$DRATE)/(8*10)))
		MIN=$(($MAX/2))
		BURST=$(((2*$MIN+$MAX)/(3*$A)))
		LIMIT=$((4*$MAX))

		tc qdisc change dev ifb0   parent 10:2 gred DP $(($I-1)) prio $(($I+7)) probability $P \
				min $MIN max $MAX avpkt $A burst $BURST limit $LIMIT \
				bandwidth ${DRATE}kbit
	done

	if [ "$V4INT" ]; then
		tc filter add dev ifb0   parent    1: protocol ip   tcindex mask 0xfc shift 2 pass_on

		tc filter add dev $IFACE parent    1: protocol ip   tcindex mask 0xfc shift 2 pass_on
		tc filter add dev $IFACE parent ffff: protocol ip   basic action mirred egress redirect dev ifb0
	fi
	if [ "$V6INT" ]; then
		tc filter add dev ifb0   parent    1: protocol ipv6 tcindex mask 0xfc shift 2 pass_on

		tc filter add dev $IFACE parent    1: protocol ipv6 tcindex mask 0xfc shift 2 pass_on
		tc filter add dev $IFACE parent ffff: protocol ipv6 basic action mirred egress redirect dev ifb0
	fi
}

qos_stop
ipt_stop
[ "x$1" = "xstop" ] && exit 0
ipt_init
ipt_rules
qos_rules
ipt_start

exit 0
